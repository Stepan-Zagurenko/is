package pack; /*Пакет (package) — это некий контейнер, который используется для того, чтобы изолировать имена классов. 
pack - название пакета */

import java.awt.*;
import java.awt.event.*;
/*	java. - Все стандартные классы, поставляемые с системой Java, хранятся в пакете java.
java.awt  - подключение пакета awt, содержащего базовые графические функции:GridLayout, BorderLayout и т.д.
"*"-включение всех элементов библиотеки awt */	
import javax.swing.*;
/*	Импортируем: 
javax.* — стандартные расширения.(Стандартные расширения (standard extensions) — это пакеты или наборы пакетов Java)
Swing - Библиотека графического интерфейса (конкретный пакет), В отличие от java.awt, javax.swing имеет более гибкую 
систему управления и более широкий набор функций
"*"-включение всех элементов библиотеки Swing (jbutton,jpanel,jlabel и т.д.)
"."(точка) используется для выделения элементов из ссылки на объект.
*/
import javax.swing.border.*;//библиотека необходимая для того, чтобы установить отступы

public class index extends JFrame{
	/*	(Public) - поля и методы класса Index доступны для всех других объектов и классов. 
	зарезервированное слово class - говорит транслятору, что мы собираемся описать новый класс Index.
	Класс наследует функции элемента JFrame, который определён в стандартной библиотеке awt.
	 JFrame - само окно. JFrame содержит в себе всё необходимое для создания и функционирования окна программы - мы 
	 используем его методы в своей программе. { }-описание класса располагается между фигурными скобками. 
	*/
	
	private static final long serialVersionUID = 1L;
	public static index frame = new index(); /* Index() - это установка компонентов (панель вкладок) на JFrame. 
	(Public) - означает что фрейм Index можно вызвать из любого файла который лежит в пакете pack.
	static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
	отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
	и переменным можно обращаться через имя класса*/
	
	public static void main(String[] args) { /*  
		Модификатор доступа public означает, что метод main(String[] args)виден и доступен любому классу. 
		static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
		отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
		и переменным можно обращаться через имя класса.
		void означает, что метод main(String[] args)не возвращает данных в программу, которая его вызвала, 
		а просто выводит на экран строку.
		В методе main слова String[] args означают,что этот может получать массив объектов с типом String, т.е. текстовые данные.
		Программа может состоять из нескольких классов, но только один из них содержит метод main().
		Все существующие реализации Java-интерпретаторов, получив команду интерпретировать класс, 
		начинают свою работу с вызова метода main. 
		*/
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				/* public - модификатор доступа, означающий, что метод run() виден и доступен любому классу.
				void ()означает, что метод run не возвращает данных в программу, которая его вызвала, 
				а просто выводит на экран строку.
				Метод run с пустыми скобками, т.е. метод не имеет аргументов(параметров)	 
				*/
				try {
		/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
		Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
		Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
		1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
		доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
		 прерывается, и управление прыгает в начало блока catch(err).
		*/
					frame.setVisible(true); //устанавливаем что окно Index (параметры короба для сабвуфера) видно пользователю

				} catch (Exception e) {
					e.printStackTrace();
					/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
					Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
					Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
					1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
					доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
					 прерывается, и управление прыгает в начало блока catch(err).
					*/
				}
			}
		});
	}
	
	
	private JPanel panel_0,panel, panel_1;//панели на которых располагаются поля и кнопки. Панели доступны только для данного класса (private)
	private JButton del, calc_v;// кнопка Рассчитать которая доступна только для данного класса
	private JLabel label1,label2,label3,label4, label5, label6,label7,label8,label9,label10,label11;
	// компонент на котором располагается текст
	public static JLabel label_in, label_out;
	public static JTextField in_a, in_h, in_l, in_t, out_a, out_h, out_l;
	/* текстовые поля в которые пользователь вводит данные, доступны для любого файла из пакета pack */
	public static JCheckBox in, out;// компонент флажок
	public static int int_in=0,int_out=0;//переменная типа integer, доступная любому классу
		/*static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
	отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
	и переменным можно обращаться через имя класса.*/
	
	
	public index() { /*Модификатор доступа public означает, что метод Index()виден и доступен любому классу.
		static означает, что не нужно создавать экземпляр(копию) объекта Index в памяти, чтобы использовать этот метод.
		Index - расположение на фрейме компонентов (панель вкладок), .*/
		setTitle("Параметры короба для сабвуфера"); //устанавливает название окна 
		setSize(640, 350); // указывает ширину (640) и высоту (350).
		setLocationRelativeTo(null);//установить посередине экрана
		
		//по закрытию формы - закрывать приложение
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        setLayout (new BorderLayout()); /*	Оператор new создает экземпляр указанного класса
	  	Метод setLayout - Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере.
 		Менеджер размещения BorderLayout - тип разбивки контейнера, при котором всё пространство контейнера разбивается 
 		на пять частей. В каждой из этих частей располагается один компонент. 
 		При добавлении компонента на контейнер с BorderLayout разработчик обязательно указывает, 
 		куда именно он хочет поместить компонент.*/

        panel_0 = new JPanel();//Панель на которой  располагаются компоненты-флажки Внутренние размеры и Внешние размеры 
        panel = new JPanel();//Панель на которой  располагаются текстовые поля и поля для ввода текста
		panel_1 = new JPanel();//Панель на которой располагается кнопки очистить и рассчитать объем


		add(panel_0, BorderLayout.NORTH);//Добавление панели panel сверху
		add(panel, BorderLayout.CENTER);//Добавление панели panel по центру
		add(panel_1, BorderLayout.SOUTH);//Добавление панели panel_1 снизу

		panel_0.setBorder(new EmptyBorder(20,10,10,10));//установка внутренних отступов
		//EmptyBorder(сверху, слева, снизу, справа)
		panel.setBorder(new EmptyBorder(10,10,50,10));//установка внутренних отступов

		/* установка менеджера компоновки GridLayout. данный менеджер компоновки располагает компоненты в таблицу */
		panel_0.setLayout(new GridLayout(1,2,10,15));//на панели 1 строка,2столбца, будут расположена компоненты флажки Внутренние размеры и Внешние размеры
		panel.setLayout(new GridLayout(5,4,10,5));/* на панеле будет 5 строк, 4 столбца, расстояние между
		 столбцами 10, расстояние между строками 5 */
		panel_1.setLayout(new GridLayout(1,2));//на панели 1 строка,2столбца, будут расположены кнопки

		label1 = new JLabel("Ширина, см:", JLabel.RIGHT); // ширина внутрен. 
		label2 = new JLabel("Ширина, см:", JLabel.RIGHT);// ширина внеш.
		label3 = new JLabel("Высота, см:", JLabel.RIGHT); //внутрен.
		label4 = new JLabel("Высота, см:", JLabel.RIGHT); //внешн.
		label5 = new JLabel("Глубина, см:", JLabel.RIGHT); //внутрен
		label6 = new JLabel("Глубина, см:", JLabel.RIGHT); //внешн.
		label7 = new JLabel("Толщина материала, см:", JLabel.RIGHT);
		label8 = new JLabel("Общий объем:", JLabel.LEFT);
		label9 = new JLabel("Наружный объем:", JLabel.LEFT);
		label10 = new JLabel(); //пустой label для того чтобы оставить место после "толщина материала"
		label11 = new JLabel();//пустой label для того чтобы оставить место после "толщина материала"
		label_in = new JLabel(); // для отображения рассчитанного общего объема 
		label_out = new JLabel(); // для отображения рассчитанного наружного объема 

		label8.setForeground(Color.RED); //цвет текста label8 (общий объем) и label9(наружный объем) - красный
		label9.setForeground(Color.RED);

		/*Обозначаем что переменные Label_1,Label_2..являются объектом JLabel и указываем какой текст будет выводиться.
		JLabel.LEFT - выравнивание по левому краю,
		JLabel.CENTER - выравнивание по центру
		*/
		
		del = new JButton("Очистить"); //Компонент кнопка. В скобках - надпись на кнопке
		calc_v = new JButton("Рассчитать объем"); //В скобках - надпись на кнопке
		
		in = new JCheckBox("Внутренние размеры");//компонент флажок 
		in.setToolTipText("Ввести внутренние размеры");
		/* setToolTipText - подсказка, которая показывается при наведении на элемент (компонент флажок)*/
		
		out = new JCheckBox("Внешние размеры");//компонент флажок 
		out.setToolTipText("Ввести внешние размеры");
		/*setToolTipText - подсказка, которая показывается при наведении на элемент (компонент флажок)*/
//Внутренние размеры	

		in_a = new JTextField();
		in_a.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		in_a.setToolTipText("Введите ширину");//всплывающая подсказка при наведении на текстовое поле
    	
		in_h = new JTextField();
		in_h.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		in_h.setToolTipText("Введите высоту");//всплывающая подсказка при наведении на текстовое поле
    			
		in_l = new JTextField();
		in_l.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		in_l.setToolTipText("Введите глубину");//всплывающая подсказка при наведении на текстовое поле

		in_t = new JTextField();
		in_t.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		in_t.setToolTipText("Введите толщину материала");//всплывающая подсказка при наведении на текстовое поле
// Внешние размеры
		out_a = new JTextField();
		out_a.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		out_a.setToolTipText("Введите ширину");//всплывающая подсказка при наведении на текстовое поле
    	
		out_h = new JTextField();
		out_h.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		out_h.setToolTipText("Введите высоту");//всплывающая подсказка при наведении на текстовое поле
    			
		out_l = new JTextField();
		out_l.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
		out_l.setToolTipText("Введите глубину");//всплывающая подсказка при наведении на текстовое поле
		
		
		//Добавление кнопок на панель panel_1
		panel_1.add(del);
		panel_1.add(calc_v);

		//Добавление флажков на панель panel_0
		panel_0.add(in);
		panel_0.add(out);
						
		//Добавление компонентов JLabel, JTextField, JCheckBox на панель panel
		panel.add(label1);
		panel.add(in_a);
		panel.add(label2);
		panel.add(out_a);
		
		panel.add(label3);
		panel.add(in_h);
		panel.add(label4);
		panel.add(out_h);
		
		panel.add(label5);
		panel.add(in_l);
		panel.add(label6);
		panel.add(out_l);
		
		panel.add(label7);
		panel.add(in_t);
		panel.add(label10);
		panel.add(label11);

		panel.add(label8);
		panel.add(label_in);
		panel.add(label9);	
		panel.add(label_out);
		//Добавление компонентов JLabel, JTextField, JCheckBox на панель panel

		// поля для ввода текста недоступны пока пользователь не выберет какие размеры он будет вводить - внутренние или наружные
		in_a.setEditable(false);
		in_h.setEditable(false);
		in_l.setEditable(false);
		out_a.setEditable(false);
		out_h.setEditable(false);
		out_l.setEditable(false);
		in_t.setEditable(false);
		
	/* Слушатель события для компонента флажок Внутренние размеры*/	
		in.addItemListener(new ItemListener(){   /*Для компонента флажок устанавливаем слушатель события                                                        
			Если нажать на компонент - сработает проверка выбран флажок или снят */                                                     
			public void itemStateChanged(ItemEvent e) 
			/*. В теле метода itemStateChanged располагается код, который выполняется при смене состояния флажка. */
			{
				if (e.getSource()==in)//если событие произошло именно с флажком in, то выполняется следующее
					if(e.getStateChange()==1){ /* Если данный компонент флажок включен (==1), то это значит 
					что введены внутренние размеры */
						 int_in=1;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
						 int_out=0;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
						 out.setSelected(false);//если флажок на внешних размер был включен - выключить его
						 	
						 	// поля для ввода внутренних размеров - доступны, внешних - недоступны
							in_a.setEditable(true);
							in_h.setEditable(true);
							in_l.setEditable(true);
							out_a.setEditable(false);
							out_h.setEditable(false);
							out_l.setEditable(false);
							in_t.setEditable(true);
						}
					else { //флажок выключен
						int_in=0;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
					 	
						// поля для ввода размеров - недоступны
						in_a.setEditable(false);
						in_h.setEditable(false);
						in_l.setEditable(false);
						out_a.setEditable(false);
						out_h.setEditable(false);
						out_l.setEditable(false);
						in_t.setEditable(false);
					}
			}                                                       
    	   }); 	

/* Слушатель события для компонента флажок Внешние размеры*/	
		out.addItemListener(new ItemListener(){   /*Для компонента флажок устанавливаем слушатель события                                                        
			Если нажать на компонент - сработает проверка выбран флажок или снят */                                                     
			public void itemStateChanged(ItemEvent e) 
			/*. В теле метода itemStateChanged располагается код, который выполняется при смене состояния флажка. */
			{
				if (e.getSource()==out)//если событие произошло именно с флажком out, то выполняется следующее
					if(e.getStateChange()==1){ /* Если данный компонент флажок включен (==1), то это значит 
					что введены внешние размеры */
						 int_in=0;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
						 int_out=1;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
						 in.setSelected(false);//если флажок на внутренние размеры был включен - выключить его
						
						 // поля для ввода внешних размеров - доступны, внутренних - недоступны
							in_a.setEditable(false);
							in_h.setEditable(false);
							in_l.setEditable(false);
							out_a.setEditable(true);
							out_h.setEditable(true);
							out_l.setEditable(true);
							in_t.setEditable(true);
						}
					else { //флажок выключен
						int_out=0;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
						// поля для ввода размеров - недоступны
						in_a.setEditable(false);
						in_h.setEditable(false);
						in_l.setEditable(false);
						out_a.setEditable(false);
						out_h.setEditable(false);
						out_l.setEditable(false);
						in_t.setEditable(false);
					}
			}                                                       
    	   }); 
